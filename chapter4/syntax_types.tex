Linear qCCS is equipped with all the common features of "classical" process calculi, like action prefixes, nondeterministic choice, parallel composition and classical communication. It includes also the most general "quantum" components, like quantum communication, measurements and superoperator application (instead of unitary application). 


Linear qCCS is an \textit{asynchronous} calculus  \cite{boudolAsynchronyPicalculus1992}, meaning that the output actions $c!v$ are \textit{non-blocking}, the process can immediately continue its execution after performing an output action, without having to wait for the "reception" of the sent value, i.e. the dual input coaction. In an asynchronous calculus, a term like $c!v.P$ is not a valid process, as there cannot be any continuation after an output action. A synchronous process like $c!v_1.c!v_2.P$ is usually rewritten in an asynchronous calculus as $c!v_1 \parallel c!v_2 \parallel P$. A key consequence of asynchrony is that $P$ has no control on the order in which $v_1$ and $v_2$ will be received.

We adopted a state-of-the-art asynchronous system as it simplifies the syntax, works well with linearity, and reduces the conditions to be checked to ensure single ownership of qubits.

\subsection{Syntax}

The syntax of lqCCS is designed to be consistent with qCCS, with a few exceptions. The processes are divided between parallel processes and sequential process, a simple syntax for expression is made explicit, output actions do not have a continuation, and the guard operator is substituted by a \textbf{If Then Else} operator.

A lqCCS \textit{pre}-term is generated by the syntax:
\begin{align*}
  P \Coloneqq &\ K \mid c!e \mid P \parallel P  \mid  P \{f\} \mid P \setminus c\\[0.1cm]
  K \Coloneqq &\ nil \mid \tau . P \mid \mathcal{E}(\widetilde{x}) . P \mid M(\widetilde{x} \rhd y) . P \mid c?x . P \mid \\[0.1cm]
  &\ K + K \mid \ITE{e}{P}{P} \\[0.1cm]
  e \Coloneqq &\ x \mid b \mid n \mid q \mid \neg e \mid e \lor e \mid e \leq e
\end{align*}	
where $b \in \mathbb{B}$, $n \in \mathbb{N}$, $x, y \in \text{Var}$, $q \in \text{QNames}$, $c \in \text{Chan}$, with Var a denumerable set of variable names, \note{QNames a finite set of qubit names}, and Chan a set of channel names. We use $\widetilde{x}$ to indicate a tuple of variables $x_1, \ldots x_n$.

We say that the channel name $c$ is \textit{bound} in $P\setminus c$, and it is \textit{free} when it isn't bound by any restriction operator. We denote with $fc(P)$ the set of free channels of $P$.

We use $discard(e)$ as syntactic sugar for $c!e \setminus c$, and $discard(\widetilde{e})$ as syntactic sugar for $discar(e_1)\parallel \ldots\parallel discard(e_n)$.

The expressions contain only simple operators $\neg$, $\vee$, $\leq$, but it can be obviously extended with $\wedge, \Rightarrow, \geq, =$ and so on.

lqCCS features a boolean match operator, \textbf{If $e$ Then $P_1$ Else $P_2$}, that can be understood as the qCCS-equivalent $[e]P_1 + [\neg e]P_2$. The difference between this conditional operator and the usual "sum of guards" approach is that the former always evolves in exactly one branch. With the guard construct is instead possible to write guards that are neither mutually exclusive nor cover all the possibilies, like $c?x.[x > 0].P + [x < 0].Q$. As we will see, the  \textbf{If Then Else} construct is helpful when constructing linear processes.

Differently from qCCS, lqCCS has no recursive processes, in order to simplify the type system and the comparisons with other calculi.


\subsection{Type System}

CQP type system, as well as the equivalent syntactic rules for qCCS, treats quantum name communication in an affine way: each quantum variable can be sent at most once. This allows processes like 
\[ P = H[q].\nil \qquad Q = X[q].\nil\]

This syntax has created a crucial ambiguity in the literature, that has consequences on the different notion of bisimilarity defined in QPAlg/CQP and qCCS. In QPAlg and CQP, the qubit $q$, owned by the processes $P$ and $Q$ is \textit{not} visible for an outside observer, as it is never sent. In qCCS, the qubit $q$ \textit{is} indeed visible for an external observer. As explained in section \ref{stateOfTheAr_Bisimulation}. In QPAlg/CQP $P$ and $Q$ are considered bisimilar, while in qCCS they are not.

To resolve this ambiguity, we introduce a \textit{linear} type system, where each quantum variable must be sent exactly once. A linear type system rejects the two processes above, while for example accepts processes like
\[P' = H[q].c!q \qquad Q' = X[q].c!q\]
that are not bisimilar both in QPALg/CQP and in qCCP.

The typing judgment are of the form $\Gamma \vdash e : T$ for classical expressions, $\Sigma \vdash e$ for quantum expressions, and $\Gamma; \Sigma \vdash P$ for processes.
\begin{itemize}
\item $\Gamma$ is a typing context, namely a set of typing assumptions $x:T$, both for classical and quantum variables, and for classical and quantum channels. The possible types for a variables and expressions are $\set{\mathcal{Q}, \mathbb{N}, \mathbb{B}}$, while the possible types for channels are $\set{\hat{\mathcal{Q}}, \hat{\mathbb{N}}, \hat{\mathbb{B}}}$. $\Gamma$ follows the usual structural typing rules, and we write $\Gamma, x: T$ to denote the union of the sets $\Gamma$ and $\set{x: T}$. We also use the notation
\[\Gamma - x = \begin{cases}
\Gamma \setminus \{x : T\} &\text{ if } x: T \in \Gamma \text{ for some } T \\
\Gamma &\text{ otherwise}
\end{cases}\]
\item $\Sigma$ is a set of (quantum) variables, that are subject to linear typing rules. We write $\Sigma, x$ to denote the union of the \textit{disjoint} sets $\Sigma$ and $\set{x}$.
\end{itemize}

The type system is inspired from the affine type system of CQP. To transform an affine system in a linear system, is necessary to remove the \textit{weakening} rule for $\Sigma$:
\[ \infer[\mbox{\footnotesize\scshape QWeak}]{\Gamma; \Sigma,q \vdash P}{\Gamma; \Sigma \vdash P}
\]
that allows to introduce a quantum name $q$ in $\Sigma$ even if it is not sent by $P$. In CQP, weakening is not an explicit rule of the typesystem, but is used implicitly in various rules, making it an affine type system.

We report in figure \ref{typesystem} the type system for Linear qCCS.

\begin{figure}[h!]
\caption{Type system for Linear qCCS}
\label{typesystem}
\begin{gather*}
\infer[\mbox{\footnotesize\scshape CBool}]{\vdash b : \mathbb{B}}{b \in \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape CNat}]{\vdash n : \mathbb{N}}{n \in \mathbb{N}} \qquad
\infer[\mbox{\footnotesize\scshape QVar}]{\set{x} \vdash x}{} \qquad
\infer[\mbox{\footnotesize\scshape CVar}]{x : T \vdash x : T}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape BoolOr}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \lor e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{B} & \Gamma_2 \vdash e_2 : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape BoolNeg}]{\Gamma \vdash \neg e : \mathbb{B}}{\Gamma \vdash e : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape NatLEq}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \leq e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{N} & \Gamma_2 \vdash e_2 : \mathbb{N}} \\[0.2cm]
 \infer[\mbox{\footnotesize\scshape CWeak}]{\Gamma, x : T; \Sigma \vdash P}{\Gamma; \Sigma \vdash P & \text{$x$ fresh}} \\[0.2cm]
% \infer[\mbox{\footnotesize\scshape QWeak}]{\Gamma; \Sigma, x \vdash P}{\Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Nil}]{\emptyset; \emptyset \vdash nil}{} \qquad
\infer[\mbox{\footnotesize\scshape Tau}]{\Gamma; \Sigma \vdash \tau . P}{ \Gamma; \Sigma \vdash P} \qquad
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape Guard}]{\Gamma \cup \Gamma_1 \cup \Gamma_2; \Sigma \vdash \ITE{e}{P_1}{P_2}}{\Gamma \vdash e : \mathbb{B} & \Gamma_1; \Sigma \vdash P_1 & \Gamma_2; \Sigma \vdash P_2} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QOp}]
{\Gamma; \Sigma \vdash \mathcal{E}(\widetilde{x}) . P}
{\mathcal{E}: Op(n) & |\widetilde{x}| = n & \forall i, j \ldotp x_i \neq x_j & \Sigma \vdash \widetilde{x} & \Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QMeas}]{\Gamma; \Sigma \vdash M(\widetilde{x} \rhd y) . P}
{\forall i, j \ldotp x_i \neq x_j & \note{\text{$y$ fresh}} & \Sigma \vdash \widetilde{x} & \Gamma, y : \mathbb{N}; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape CRecv}]
{\Gamma, c : \hat{T}; \Sigma \vdash c?x . P}
{\note{\text{$x$ fresh}} & T \neq \mathcal{Q} & \Gamma, x : T; \Sigma \vdash P} 
\qquad
\infer[\mbox{\footnotesize\scshape QRecv}]
{\Gamma, c : \hat{\mathcal{Q}}; \Sigma \vdash c?x . P}
{\note{\text{$x$ fresh}} & \Gamma, x : \mathcal{Q}; \Sigma, x \vdash P} 
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape CSend}]{\Gamma, c : \hat{T}; \emptyset \vdash c!e}{T \neq \mathcal{Q} & \Gamma \vdash e : T} \qquad
\infer[\mbox{\footnotesize\scshape QSend}]{c : \hat{\mathcal{Q}}, e:\mathcal{Q} ; \set{e} \vdash c!e}{} \\[0.2cm]
%\infer[\mbox{\footnotesize\scshape QDiscard}]{e:\mathcal{Q} ; \set{e} \vdash discard(e)}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Sum}]{\bigcup_{i \in I}\Gamma_i; \Sigma \vdash \sum_{i \in I} P_i}{\forall i \ldotp \Gamma_i; \Sigma_i \vdash P_i} \qquad 
\infer[\mbox{\footnotesize\scshape Par}]{\bigcup_{i \in I}\Gamma_i; \bigcup_{i \in I}\Sigma_i \vdash \bigparallel_{i \in I} P_i}
{\forall i, j \ldotp \Sigma_i \cap \Sigma_j = \emptyset & \forall i \ldotp \Gamma_i; \Sigma_i \vdash P_i} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Rename}]{\Gamma; \Sigma \vdash P \{f\}}{f(\Gamma); \Sigma \vdash f(P)} \qquad
\infer[\mbox{\footnotesize\scshape Restrict}]{\Gamma - c; \Sigma \vdash P \setminus c}{\Gamma; \Sigma \vdash P} \\[0.3cm]
\end{gather*}
\end{figure}

Thanks to the asynchronous syntax, a single typing rule {\scshape Par} is sufficient to guarantee single ownership of qubits, instead of the two different rules for $P \parallel Q$ and $c!v.P$ needed in CQP. Besides, all sequential processes that use some quantum variables must end with the terminal process $c!q$, and only the processes that do not own any quantum variable end with $\nil$. 

Notice that in a well typed process $P + Q$, it must be $\Gamma; \Sigma \vdash P$ and $\Gamma'; \Sigma \vdash Q$ for the same $\Sigma$, i.e. $P$ and $Q$ must send the same quantum variables. The same holds also for $\ITE{e}{P}{Q}$, as happens in a statically typed programming language. The if-then-else construct, where in any case one of the two branches is chosen, has been introduced specifically to write conditional processes in a linear setting. Using the simpler "sum of guards" construct $[e_1].P + [e_2].P$ of qCCS, there is the possibility that both $e_1$ and $e_2$ evaluate to $ff$, and so a safe type system must require that $\Gamma; \emptyset \vdash [e_1].P$ and $\Gamma'; \emptyset \vdash [e_2].Q$, i.e. that $P$ and $Q$ do not use any quantum variable. 

The purpose of this linear type system is to force the user to explicitly choose if the qubits used by a process $P$ should be considered  observable or not when $P$ ends its computation. Since a process $H[q].nil$ is not well typed, one must choose between
\[ P = H[q].c!q \qquad P' = H[q].discard(q)
\]
(recall that $discard(q)$ is syntactic sugar for $c!q\setminus c$)

In the first case, after the execution of $P$ the qubit $q$ is observable, both for QPAlg/CQP and qCCS. In the second case, $P'$ ends up in a deadlock process $c!q \setminus c$, as we will see in the next section. So in $P'$ the qubit $q$ is never sent, but remains part of the free quantum variables of $P'$, so is not observable both for QPAlg/CQP and qCCS. 

In other words, writing processes like $P$, that always send their qubit, we obtain the observable properties assumed in qCCS, where the quantum sate is visible. Writing processes like $P'$, that always discard their qubits, we obtain the observable properties of QPAlg/CQP, where the state is invisible. Linear qCCS allows to mix the two notions, specifying which qubits should be visible for an external observer and which should not.

Finally, observe that the construct $discard(q) = c!q \setminus c$ is implementable also in standard qCCS, $\ITE{e}{P}{Q}$ is equivalent to $[e].P + [\neg e].Q$, and so the well-typed terms of lqCCS are a subset of the valid terms of qCCS, inteded to capture only the asynchronous, unambiguous linear processes.

\subsection{Contexts}
A typed context $B$ is generated by the grammar
\[
B \Coloneqq \ [\_]_{\Gamma; \Sigma} \mid B \parallel P
\]
according to the typing rules:

\[
  \infer[\mbox{\footnotesize\scshape Hole}]{\Gamma; \Sigma \vdash [\blank]_{\Gamma; \Sigma}}{}
\qquad
\infer[\mbox{\footnotesize\scshape ParHole}]{\Gamma_1 \cup \Gamma_2; \Sigma_1 \cup \Sigma_2 \vdash B \parallel P}
{\Gamma_1; \Sigma_1 \vdash B & \Gamma_2; \Sigma_2 \vdash P & \Sigma_1 \cap \Sigma_2 = \emptyset}
\]


\begin{theorem}
	Given any context $B[\blank]$ of type $\Gamma; \Sigma$, with hole of type $\Gamma'; \Sigma'$, and any process $P$ s.t. $\Gamma'; \Sigma' \vdash P$, it holds that $\Gamma; \Sigma \vdash B[P]$ 
\end{theorem}
\begin{proof}
	Trivial.
\end{proof}
\subsection{Syntax}

\begin{align*}
  P \Coloneqq &\ K \mid c!e 
%  \mid discard(e) 
  \mid P \parallel P \\[0.1cm]
  K \Coloneqq &\ nil \mid \tau . P \mid \mathcal{E}(\widetilde{x}) . P \mid M(\widetilde{x} \rhd y) . P \mid c?x . P \mid \\[0.1cm]
  &\ \ITE{e}{P}{P} \mid K + K \mid P \{f\} \mid P \setminus c \\[0.1cm]
  e \Coloneqq &\ x \mid b \mid n \mid q \mid \neg e \mid e \lor e \mid e \leq e
\end{align*}	
where $b \in \mathbb{B}$, $n \in \mathbb{N}$, $x \in \text{Var}$, $q \in \text{QC}$, with $Var$ a denumerable set of variable names, and
QC a set of names with cardinality equal to the size of the chosen Hilbert space.

We use $discard(e)$ as syntactic sugar for $c!e \setminus c$. And x tilde for etc etc.

\subsection{Type System}

Variables Types: $\set{\mathcal{Q}, \mathbb{N}, \mathbb{B}}$
Channel types: $\set{\hat{\mathcal{Q}}, \hat{\mathbb{N}}, \hat{\mathbb{B}}}$

\begin{gather*}
\infer[\mbox{\footnotesize\scshape CBool}]{\vdash b : \mathbb{B}}{b \in \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape CNat}]{\vdash n : \mathbb{N}}{n \in \mathbb{N}} \qquad
\infer[\mbox{\footnotesize\scshape QVar}]{\set{x} \vdash x}{} \qquad
\infer[\mbox{\footnotesize\scshape CVar}]{x : T \vdash x : T}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape BoolOr}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \lor e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{B} & \Gamma_2 \vdash e_2 : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape BoolNeg}]{\Gamma \vdash \neg e : \mathbb{B}}{\Gamma \vdash e : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape NatLEq}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \leq e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{N} & \Gamma_2 \vdash e_2 : \mathbb{N}} \\[0.2cm]
 \infer[\mbox{\footnotesize\scshape CWeak}]{\Gamma, x : T; \Sigma \vdash P}{\Gamma; \Sigma \vdash P & \text{$x$ fresh}} \\[0.2cm]
% \infer[\mbox{\footnotesize\scshape QWeak}]{\Gamma; \Sigma, x \vdash P}{\Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Nil}]{\emptyset; \emptyset \vdash nil}{} \qquad
\infer[\mbox{\footnotesize\scshape Tau}]{\Gamma; \Sigma \vdash \tau . P}{ \Gamma; \Sigma \vdash P} \qquad
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape Guard}]{\Gamma \cup \Gamma_1 \cup \Gamma_2; \Sigma \vdash \ITE{e}{P_1}{P_2}}{\Gamma \vdash e : \mathbb{B} & \Gamma_1; \Sigma \vdash P_1 & \Gamma_2; \Sigma \vdash P_2} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QOp}]
{\Gamma; \Sigma \vdash \mathcal{E}(\widetilde{x}) . P}
{\mathcal{E}: Op(n) & |\widetilde{x}| = n & \forall i, j \ldotp x_i \neq x_j & \Sigma \vdash \widetilde{x} & \Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QMeas}]{\Gamma; \Sigma \vdash M(\widetilde{x} \rhd y) . P}
{\forall i, j \ldotp x_i \neq x_j & \text{$y$ fresh} & \Sigma \vdash \widetilde{x} & \Gamma, y : \mathbb{N}; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape CRecv}]
{\Gamma, c : \hat{T}; \Sigma \vdash c?x . P}
{\text{$x$ fresh} & T \neq \mathcal{Q} & \Gamma, x : T; \Sigma \vdash P} 
\qquad
\infer[\mbox{\footnotesize\scshape QRecv}]
{\Gamma, c : \hat{\mathcal{Q}}; \Sigma \vdash c?x . P}
{\text{$x$ fresh} & \Gamma, x : \mathcal{Q}; \Sigma, x \vdash P} 
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape CSend}]{\Gamma, c : \hat{T}; \emptyset \vdash c!e}{T \neq \mathcal{Q} & \Gamma \vdash e : T} \qquad
\infer[\mbox{\footnotesize\scshape QSend}]{c : \hat{\mathcal{Q}}, e:\mathcal{Q} ; \set{e} \vdash c!e}{} \\[0.2cm]
%\infer[\mbox{\footnotesize\scshape QDiscard}]{e:\mathcal{Q} ; \set{e} \vdash discard(e)}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Sum}]{\bigcup_{i \in I}\Gamma_i; \Sigma \vdash \sum_{i \in I} P_i}{\forall i \ldotp \Gamma_i; \Sigma_i \vdash P_i} \qquad 
\infer[\mbox{\footnotesize\scshape Par}]{\bigcup_{i \in I}\Gamma_i; \bigcup_{i \in I}\Sigma_i \vdash \bigparallel_{i \in I} P_i}
{\forall i, j \ldotp \Sigma_i \cap \Sigma_j = \emptyset & \forall i \ldotp \Gamma_i; \Sigma_i \vdash P_i} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Rename}]{\Gamma; \Sigma \vdash P \{f\}}{f(\Gamma); \Sigma \vdash f(P)} \qquad
\infer[\mbox{\footnotesize\scshape Restrict}]{\Gamma - c; \Sigma \vdash P \setminus c}{\Gamma; \Sigma \vdash P} \\[0.3cm]
\end{gather*}

Where $$\Gamma - c = \begin{cases}
\Gamma \setminus \{c : \hat{T}\} \text{ if } c: \hat{T} \in \Gamma \text{ for some } \hat{T} \\
\Gamma \text{ otherwise}
\end{cases}$$

We say that the channel name $c$ is \textit{bound} in $P\setminus c$, and it is \textit{free} when it isn't bound by any restriction operator. We denote with $fc(P)$ the set of free channels of $P$.

\begin{definition}
  Assume a fixed set  $QVar = {q_1, q_2, \ldots q_n}$ of quantum variables, where each variable $q_i$ refers to a unique qubit with state space $\calH_i$. We denote as $\calH_{QVar}$ the $2^n$-dimensional Hilbert space $\bigoplus_{i=1}^n \calH_i$.

Let $P$ be a process and $\rho \in \mathcal{D}(\calH_{QVar})$ an arbitrary partial density operator. $\Gamma; \Sigma \vdash \langle \rho, P \rangle$ iff $\Gamma; \Sigma \vdash P$ and $\Sigma \subseteq QVar$.

  Let $I$ be an arbitrary index set. $\Gamma; \Sigma \vdash \boxplus_{i \in I} \langle \rho_i, P_i \rangle$ iff for each $i \in I$ such that $\rho_i \neq \mathbf{0}$,
  then $\Gamma; \Sigma \vdash \langle \rho_i, P_i \rangle$.
\end{definition}

%{\color{red} 
%Togliere Qvar da Gamma
%
%Rimuovere fresh da recv
%
%Aggiornare il proofs.
%}


\subsection*{Contexts}
A typed context $B$ is generated by the grammar
\[
B \Coloneqq \ [\_]_{\Gamma; \Sigma} \mid B \parallel P
\]
according to the typing rules:

\[
  \infer[\mbox{\footnotesize\scshape Hole}]{\Gamma; \Sigma \vdash [\blank]_{\Gamma; \Sigma}}{}
\qquad
\infer[\mbox{\footnotesize\scshape ParHole}]{\Gamma_1 \cup \Gamma_2; \Sigma_1 \cup \Sigma_2 \vdash B \parallel P}
{\Gamma_1; \Sigma_1 \vdash B & \Gamma_2; \Sigma_2 \vdash P & \Sigma_1 \cap \Sigma_2 = \emptyset}
\]


\begin{theorem}
	Given any context $B[\blank]$ of type $\Gamma; \Sigma$, with hole of type $\Gamma'; \Sigma'$, and any process $P$ s.t. $\Gamma'; \Sigma' \vdash P$, it holds that $\Gamma; \Sigma \vdash B[P]$ 
\end{theorem}
\begin{proof}
	Trivial.
\end{proof}
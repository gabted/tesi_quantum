Linear qCCS is equipped with all the common features of "classical" process calculi, like action prefixes, nondeterministic choice, parallel composition and classical communication. It includes also the most general "quantum" components, like quantum communication, measurements and superoperator application (that subsumes unitary transformations). 


Linear qCCS is an \textit{asynchronous} calculus  \cite{boudolAsynchronyPicalculus1992}, meaning that the output actions $c!v$ are \textit{non-blocking}, the process cannot wait for the "reception" of the sent value, i.e. the dual input coaction. In an asynchronous calculus, a term like $c!v.P$ is not a valid process, as there cannot be any continuation after an output action. A synchronous process like $c!v_1.c!v_2.P$ is usually rewritten in an asynchronous calculus as $c!v_1 \parallel c!v_2 \parallel P$. A key consequence of asynchrony is that the process has no control on the order in which $v_1$ and $v_2$ will be received.

We adopted a state-of-the-art asynchronous system as it simplifies the syntax, works well with linearity, and reduces the conditions to be checked to ensure single ownership of qubits.

\subsection{Syntax}

The syntax of lqCCS is designed to be consistent with qCCS, with a few exceptions: We divide the syntactic terms in parallel processes $P$ and sequential processes $K$, we provide an simple syntax for expressions, we consider only output actions without a continuation, and we replace the guard operator with a \textbf{If Then Else} operator.

A lqCCS \textit{pre}-term is generated by the syntax:
\begin{align*}
  P \Coloneqq &\ K \mid c!e \mid P \parallel P  \mid  P \{f\} \mid P \setminus c\\[0.1cm]
  K \Coloneqq &\ nil \mid \tau . P \mid \mathcal{E}(\widetilde{x}) . P \mid M(\widetilde{x} \rhd y) . P \mid c?x . P \mid \\[0.1cm]
  &\ K + K \mid \ite{e}{P}{P} \\[0.1cm]
  e \Coloneqq &\ x \mid b \mid n \mid \neg e \mid e \lor e \mid e \leq e
\end{align*}	
where $b \in \mathbb{B}$, $n \in \mathbb{N}$, $x, y \in \text{Var}$, $c \in \text{Chan}$, with Var a denumerable set of variable names, and Chan a set of channel names. We use $\widetilde{x}$ to indicate a tuple of variables $x_1, \ldots x_n$.

Each superoperator symbol $\sop$ has a given arity $n$, and denotes a particular trace preserving superoperator on $\Hto{n}$, where $\calH$ is the two-dimensional Hilbert space of a qubit. We will often uses symbols like $\sop_U$ to denote the superoperator $\sop(\rho) = U \rho U^\dagger$, but also symbols like $Set_0$, $Set_+$, 
$Set_{\Phi^+}$ to denote the corresponding superoperators. We write $\sop: Op(n)$ to indicate  that $\sop$ is a suoperoperator symbol with arity $n$.

Each measurement symbol $M$ has a given arity $n$, and denotes a measurement $\set{M_0, \ldots, M_{k-1}}$ with $k$ different outcomes, where for each $0 \leq m \leq k-1$, $M_m$ is a linear operator on $\Hto{n}$ and $\calH$ is the two-dimensional Hilbert space of a qubit. We will use the symbol $M_{01}$ to denote the one-qubit measurement on the computational base $\set{M_0 = \proj{0}, M_1=\proj{1}}$, and the symbol $M_\pm$ to denote the one-qubit measurement on the diagonal base $\set{M_0 = \proj{+}, M_1 = \proj{-}}$. We write $M: Meas(n)$ to indicate  that $M$ is a measurement symbol with arity $n$.

We say that the channel name $c$ is \textit{bound} in $P\setminus c$, and it is \textit{free} when it isn't bound by any restriction operator. We denote with $\mathit{fc}(P)$ the set of free channels of $P$.

We use $discard(e)$, as syntactic sugar for $c!e \setminus c$, and $discard(\widetilde{e})$, or also $disc(\widetilde{e})$, as syntactic sugar for $discard(e_1)\parallel \ldots\parallel discard(e_n)$.

The expressions contain simple operators $\neg$, $\vee$, $\leq$, and  can be trivially extended with $\wedge, \Rightarrow, \geq, =$ and so on.

lqCCS features a boolean match operator, \textbf{if $e$ then $P_1$ else $P_2$}, roughly equivalent to $[e]P_1 + [\neg e]P_2$ of qCCS. The advantage of the former is that it always evolves in exactly one branch. On the countrary, guarded sums may be neither mutually  exclusive nor exaustive, like in $c?x.[x > 0].P + [x < 0].Q$. As we will see, the \textbf{if then else} construct is helpful when constructing linear processes.

We decided to keep the presentation as simple as possible, hence to mit recursively defined processes. This simplifies our type system and the comparison with other calculi.


\subsection{Type System}

CQP type system, as well as the equivalent syntactic rules for qCCS, treats quantum name communication in an affine way: each quantum variable can be sent at most once. This allows processes like 
\[ P = H[q].\nil \qquad Q = X[q].\nil\]

This syntax has created a crucial ambiguity in the literature, with consequences on the different notion of bisimilarity defined in QPAlg/CQP and qCCS. In QPAlg and CQP, the qubit $q$, owned by the processes $P$ and $Q$ above is \textit{not} visible for an outside observer, as it is never sent. In qCCS, the qubit $q$ \textit{is} indeed visible for an external observer, as explained in section \ref{stateOfTheAr_Bisimulation}. In QPAlg/CQP $P$ and $Q$ are bisimilar, while in qCCS they are not.

To resolve this ambiguity, we introduce a \textit{linear} type system, where each quantum variable must be sent exactly once. A linear type system rejects the two processes above, while for example accepts the following
\[P' = H[q].c!q \qquad Q' = X[q].c!q\]
that are bisimilar neither in QPAlg/CQP nor in qCCP.

Notice that in lqCCS is also possible to write processes like 
\[P'' = H[q].discard(q) \qquad Q'' = X[q].discard\]
$P''$ and $Q''$ follow an approach a-la QPAlg, where the qubit $q$ is not visible, and are in fact bisimilar.


The typing judgment are of the form $\Gamma \vdash e : T$ for classical expressions, $\Sigma \vdash e$ for quantum expressions, and $\Gamma; \Sigma \vdash P$ for processes.
\begin{itemize}
\item $\Gamma$ is a typing context, namely a set of typing assumptions $x:T$, both for classical variables and for classical and quantum channels. The possible types for a variables and expressions are $\set{\mathbb{N}, \mathbb{B}}$, while the possible types for channels are $\set{\hat{\mathcal{Q}}, \hat{\mathbb{N}}, \hat{\mathbb{B}}}$. $\Gamma$ follows the usual structural typing rules, and we write $\Gamma, x: T$ to denote the union of the sets $\Gamma$ and $\set{x: T}$. We also use the notation
\[\Gamma - x = \begin{cases}
\Gamma \setminus \{x : T\} &\text{ if } x: T \in \Gamma \text{ for some } T \\
\Gamma &\text{ otherwise}
\end{cases}\]
\item $\Sigma$ is a set of quantum variables, that are subject to linear typing rules. We write $\Sigma, x$ to denote the union of the \textit{disjoint} sets $\Sigma$ and $\set{x}$.
\end{itemize}


We report in figure \ref{typesystem} the type system for Linear qCCS.


\begin{figure}[h!]
\caption{Type system for Linear qCCS}
\label{typesystem}
\begin{gather*}
\infer[\mbox{\footnotesize\scshape CBool}]{\vdash b : \mathbb{B}}{b \in \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape CNat}]{\vdash n : \mathbb{N}}{n \in \mathbb{N}} \qquad
\infer[\mbox{\footnotesize\scshape QVar}]{\set{x} \vdash x}{} \qquad
\infer[\mbox{\footnotesize\scshape CVar}]{x : T \vdash x : T}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape BoolOr}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \lor e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{B} & \Gamma_2 \vdash e_2 : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape BoolNeg}]{\Gamma \vdash \neg e : \mathbb{B}}{\Gamma \vdash e : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape NatLEq}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \leq e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{N} & \Gamma_2 \vdash e_2 : \mathbb{N}} \\[0.2cm]
 \infer[\mbox{\footnotesize\scshape CWeak}]{\Gamma, x : T; \Sigma \vdash P}{\Gamma; \Sigma \vdash P & \text{$x$ fresh}} \\[0.2cm]
% \infer[\mbox{\footnotesize\scshape QWeak}]{\Gamma; \Sigma, x \vdash P}{\Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Nil}]{\emptyset; \emptyset \vdash nil}{} \qquad
\infer[\mbox{\footnotesize\scshape Tau}]{\Gamma; \Sigma \vdash \tau . P}{ \Gamma; \Sigma \vdash P} \qquad
\infer[\mbox{\footnotesize\scshape ITE}]{\Gamma \cup \Gamma_1 \cup \Gamma_2; \Sigma \vdash \ite{e}{P_1}{P_2}}{\Gamma \vdash e : \mathbb{B} & \Gamma_1; \Sigma \vdash P_1 & \Gamma_2; \Sigma \vdash P_2} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QOp}]
{\Gamma; \Sigma \vdash \mathcal{E}(\widetilde{x}) . P}
{\mathcal{E}: Op(n) & |\widetilde{x}| = n & \forall i, j \ldotp x_i \neq x_j & \Sigma \vdash \widetilde{x} & \Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QMeas}]{\Gamma; \Sigma \vdash M(\widetilde{x} \rhd y) . P}
{M: Meas(n) & |\widetilde{x}| = n &  \forall i, j \ldotp x_i \neq x_j  & \Sigma \vdash \widetilde{x} & \Gamma, y : \mathbb{N}; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape CRecv}]
{\Gamma, c : \hat{T}; \Sigma \vdash c?x . P}
{\Gamma, x : T; \Sigma \vdash P} 
\qquad
\infer[\mbox{\footnotesize\scshape QRecv}]
{\Gamma, c : \hat{\mathcal{Q}}; \Sigma \vdash c?x . P}
{ \Gamma; \Sigma, x \vdash P} 
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape CSend}]{\Gamma, c : \hat{T}; \emptyset \vdash c!e}{ \Gamma \vdash e : T} \qquad
\infer[\mbox{\footnotesize\scshape QSend}]{c : \hat{\mathcal{Q}} ; \set{e} \vdash c!e}{} \\[0.2cm]
%\infer[\mbox{\footnotesize\scshape QDiscard}]{e:\mathcal{Q} ; \set{e} \vdash discard(e)}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Sum}]{\Gamma_1 \cup \Gamma_2; \Sigma \vdash P_1 + P_2}{\Gamma_1; \Sigma \vdash P_1 & \Gamma_2; \Sigma \vdash P_2} \qquad 
\infer[\mbox{\footnotesize\scshape Par}]{\Gamma_i \cup \Gamma_2; \Sigma_1 \cup \Sigma_2 \vdash P_1 \parallel P_2}
{\Sigma_1 \cap \Sigma_2 = \emptyset & \Gamma_1; \Sigma_1 \vdash P_1 & \Gamma_2 q; \Sigma_2 \vdash P_2} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Rename}]{\Gamma; \Sigma \vdash P \{f\}}{f(\Gamma); \Sigma \vdash f(P)} \qquad
\infer[\mbox{\footnotesize\scshape Restrict}]{\Gamma - c; \Sigma \vdash P \setminus c}{\Gamma; \Sigma \vdash P} \\[0.3cm]
\end{gather*}
\end{figure}

Thanks to the asynchronous syntax, a single typing rule {\scshape Par} is sufficient to guarantee single ownership of qubits (instead of the two different rules for $P \parallel Q$ and $c!v.P$ needed in CQP). Besides, weakening does not hold, and all sequential processes that use some quantum variables must end with the terminal process $c!q$, and only the processes that do not own any quantum variable end with $\nil$. 

Notice that in a well typed process $P + Q$, it must be $\Gamma; \Sigma \vdash P$ and $\Gamma'; \Sigma \vdash Q$ for the same $\Sigma$, i.e. $P$ and $Q$ must send (or discard) the same quantum variables. The same holds also for $\ite{e}{P}{Q}$, as common in statically typed programming languages. The $\ite{}{}{}$ construct, where in any case one of the two branches is chosen, has been introduced specifically to write conditional processes in a linear setting. Note that using the simpler "sum of guards" construct $[e_1].P + [e_2].P$ of qCCS, both $e_1$ and $e_2$ may evaluate to $ff$, hence a safe type system must require that $P$ and $Q$ do not use any quantum variable, i.e.  $\Gamma; \emptyset \vdash [e_1].P$ and $\Gamma'; \emptyset \vdash [e_2].Q$, which is prohibitive.  

The purpose of our linear type system is to force the user to explicitly choose if the qubits used by a process $P$ should be considered  observable or not when $P$ ends its computation. Consider as an example a process that just applies an Hadamard gate  to a qubit $q$. $H[q].\nil$ is not well typed, hence one must choose
between 
\[ P = H[q].c!q \quad\text{ and }\quad P' = H[q].discard(q)
\]
(recall that $discard(q)$ is syntactic sugar for $c!q\setminus c$)

In the first case the qubit $q$ is observable, both for QPAlg/CQP and qCCS. In the second case, $P'$ ends up in a deadlock process $c!q \setminus c$, where the qubit $q$ is never sent, and it is not observable both for QPAlg/CQP and qCCS (techincally because it remains part of the free quantum variables of $P'$). 

In other words, writing processes like $P$, that always send their qubit, we obtain the observable properties assumed in qCCS, where the quantum sate is visible. Writing processes like $P'$, that always discard their qubits, we obtain the observable properties of QPAlg/CQP, where the state is invisible. Linear qCCS allows to mix the two notions, specifying which qubits should be visible for an external observer and which should not.

Finally, observe that the construct $discard(q) = c!q \setminus c$ is implementable also in standard qCCS, $\ite{e}{P}{Q}$ is equivalent to $[e].P + [\neg e].Q$, and so the well-typed terms of lqCCS are a subset of the valid terms of qCCS, inteded to capture only the asynchronous, unambiguous linear processes.

\subsection{Contexts}
After introducing the syntax and type system of lqCCS, we can now define contexts, that will be useful in section \ref{bisimulation_chapter4}. A context is usually defined as a "process with a hole", but in our case we need to restrict ourselves to contexts that respect the linear typing rules. So we introduce \textit{typed contexts}, i.e. contexts that "accept" only processes typed by a specific $\Gamma;\Sigma$, and are admitted by the linear type system.

\begin{definition}
A typed context $B[\blank]_{\Gamma; \Sigma}$ is generated by the grammar:
\[
B[\blank]_{\Gamma; \Sigma} \Coloneqq \ [\blank]_{\Gamma; \Sigma} \mid [\blank]_{\Gamma; \Sigma} \parallel P
\]
and for some $\Gamma'$ and $\Sigma'$, $\Gamma';\Sigma' \vdash B[\blank]_{\Gamma; \Sigma}$ according to the typing rules:
\[
  \infer[\mbox{\footnotesize\scshape Hole}]{\Gamma; \Sigma \vdash [\blank]_{\Gamma; \Sigma}}{}
\qquad
\infer[\mbox{\footnotesize\scshape ParHole}]{\Gamma_1 \cup \Gamma_2; \Sigma_1 \cup \Sigma_2 \vdash [\blank]_{\Gamma; \Sigma} \parallel P}
{\Gamma_1; \Sigma_1 \vdash [\blank]_{\Gamma; \Sigma} & \Gamma_2; \Sigma_2 \vdash P & \Sigma_1 \cap \Sigma_2 = \emptyset}
\]
\end{definition}

Given a typed context $B[\blank]_{\Gamma; \Sigma}$ and a process $P$, the process $B[P]$, obtained "filling" the hole in $B$ with $P$, is well defined only if $\Gamma;\Sigma \vdash P$.

\begin{theorem}
	Suppose a context $B[\blank]_{\Gamma; \Sigma}$ such that $\Gamma'; \Sigma' \vdash B[\blank]_{\Gamma; \Sigma}$. For any process $P$ such that $\Gamma; \Sigma \vdash P$, it holds that $\Gamma'; \Sigma' \vdash B[P]$.
\end{theorem}
\begin{proof}
	The proof is trivial, proceeding by induction on the rules {\footnotesize\scshape Hole} and {\footnotesize\scshape ParHole}.
\end{proof}

Notice that according to the given syntax, a context can be either the degenerate empty context $[\blank]_{\Gamma;\Sigma}$, or the parallel context $[\blank]_{\Gamma;\Sigma} \parallel P$ for some $P$. When used to define saturated bisimilarity (section \ref{bisimulation_chapter4}), these are the only \textit{discriminating} context, as in \cite{bonchiGeneralTheoryBarbs2014}.
Linear qCCS is equipped with all the common features of "classical" process calculi, like action prefixes, nondeterministic choice, parallel composition and classical communication. It includes also the most general "quantum" components, like quantum communication, measurements and superoperator application (instead of unitary application). 


Linear qCCS is an \textit{asynchronous} calculus  \cite{boudolAsynchronyPicalculus1992}, meaning that the output actions $c!e$ are \textit{non-blocking}, the process can immediately continue its execution after performing an output action, without having to wait for the "reception" of the sent value, i.e. the dual input coaction. In an asynchronous calculus, a term like $c!v.P$ is not a valid process, as there cannot be any continuation after an output action. A synchronous process like $c!v_1.c!v_2.P$ is usually rewritten in an asynchronous calculus as $c!v_1 \parallel c!v_2 \parallel P$. A key consequence of asynchrony is that $P$ has no control on the order in which $v_1$ and $v_2$ will be received.

We adopted a state-of-the-art asynchronous system as it simplifies both the syntax, works well with linearity, and reduces the conditions to be checked to ensure single ownership of qubits.

\subsection{Syntax}

The syntax of lqCCS is designed to be consistent with qCCS, with a few exceptions. The processes are divided between parallel processes and non-deterministic process, a simple syntax for expression is made explicit, output actions do not have a continuation, and the guard operator is substituted by a \textbf{If Then Else} operator.

A lqCCS \textit{pre}-term is generated by the syntax:
\begin{align*}
  P \Coloneqq &\ K \mid c!e \mid P \parallel P  \mid  P \{f\} \mid P \setminus c\\[0.1cm]
  K \Coloneqq &\ nil \mid \tau . P \mid \mathcal{E}(\widetilde{x}) . P \mid M(\widetilde{x} \rhd y) . P \mid c?x . P \mid \\[0.1cm]
  &\ K + K \mid \ITE{e}{P}{P} \\[0.1cm]
  e \Coloneqq &\ x \mid b \mid n \mid q \mid \neg e \mid e \lor e \mid e \leq e
\end{align*}	
where $b \in \mathbb{B}$, $n \in \mathbb{N}$, $x, y \in \text{Var}$, $q \in \text{QNames}$, with Var a denumerable set of variable names, and QNames a finite set of qubit names. $\widetilde{x}$ denotes a tuple of variables $x_1, \ldots x_n$.

We use $discard(e)$ as syntactic sugar for $c!e \setminus c$, and $discard(\widetilde{q})$ as syntactic sugar for $discar(q_1)\parallel \ldots\parallel discard(q_n)$.

The expressions contain only simple operators $\neg$, $\vee$, $\leq$, but it can be obviously extended with $\wedge, \Rightarrow, \geq, =$ and so on.

lqCCS features a boolean match operator, \textbf{If $e$ Then $P_1$ Else $P_2$}, that can be understood as the qCCS-equivalent $[e]P_1 + [\neg e]P_2$. The difference between this conditional operator and the usual "sum of guards" approach is that the former always evolves in exactly one branch. With the guard construct is instead possible to write guards that are neither mutually exclusive nor cover all the possibilies, like $c?x.[x > 0].P + [x < 0].Q$. As we will see, the  \textbf{If Then Else} construct is helpful when constructing linear processes.

Differently from qCCS, lqCCS has no recursive processes, in order to simplify the type system and the comparisons with other calculi.


\subsection{Type System}

CQP type system, as well as the equivalent syntactic rules for qCCS, treat quantum name communication in an affine way: each quantum variable can be sent at most once. This allows processes like 
\[ P = H[q].\nil \qquad Q = X[q].\nil\]

This syntax has created a crucial ambiguity in the literature, that has consequences on the different notion of bisimilarity defined in QPAlg/CQP and qCCS. In QPAlg and CQP, the qubit $q$, owned by the processes $P$ and $Q$ is \textit{not} visible for an outside observer, as it is never sent. In qCCS, the qubit $q$ \textit{is} indeed visible for an external observer. As explained in section \ref{stateOfTheAr_Bisimulation} in QPAlg/CQP $P$ and $Q$ are considered bisimilar, while in qCCS they are not.

To resolve this ambiguity, we introduce a \textit{linear} type system, where each quantum variable must be sent exactly once. The type system is inspired from the affine type system of CQP. 

The typing judgment are of the form $\Gamma \vdash e : T$ for expressions, and $\Gamma; \Sigma \vdash P$ for processes. $\Gamma$ contains typing judgments for classical and quantum variables, and for classical and quantum channels, that are not subject to linear typing rules. $\Sigma$ contains a list of quantum names, that are subject to linear typing rules.

To transform an affine system in a linear system, is necessary to remove the \textit{weakening} rule for $\Sigma$:
\[ \infer[\mbox{\footnotesize\scshape Weak}]{\Gamma; \Sigma,q \vdash P}{\Gamma; \Sigma \vdash P}
\]
that allows to introduce a quantum name $q$ in $\Sigma$ even if it is not sent by $P$. In CQP, weakening is not an explicit rule of the typesystem, but is used implicitly in various rules, making it an affine type system.



Variables Types: $\set{\mathcal{Q}, \mathbb{N}, \mathbb{B}}$
Channel types: $\set{\hat{\mathcal{Q}}, \hat{\mathbb{N}}, \hat{\mathbb{B}}}$

\begin{gather*}
\infer[\mbox{\footnotesize\scshape CBool}]{\vdash b : \mathbb{B}}{b \in \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape CNat}]{\vdash n : \mathbb{N}}{n \in \mathbb{N}} \qquad
\infer[\mbox{\footnotesize\scshape QVar}]{\set{x} \vdash x}{} \qquad
\infer[\mbox{\footnotesize\scshape CVar}]{x : T \vdash x : T}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape BoolOr}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \lor e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{B} & \Gamma_2 \vdash e_2 : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape BoolNeg}]{\Gamma \vdash \neg e : \mathbb{B}}{\Gamma \vdash e : \mathbb{B}} \qquad
\infer[\mbox{\footnotesize\scshape NatLEq}]{\Gamma_1 \cup \Gamma_2 \vdash e_1 \leq e_2 : \mathbb{B}}{\Gamma_1 \vdash e_1 : \mathbb{N} & \Gamma_2 \vdash e_2 : \mathbb{N}} \\[0.2cm]
 \infer[\mbox{\footnotesize\scshape CWeak}]{\Gamma, x : T; \Sigma \vdash P}{\Gamma; \Sigma \vdash P & \text{$x$ fresh}} \\[0.2cm]
% \infer[\mbox{\footnotesize\scshape QWeak}]{\Gamma; \Sigma, x \vdash P}{\Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Nil}]{\emptyset; \emptyset \vdash nil}{} \qquad
\infer[\mbox{\footnotesize\scshape Tau}]{\Gamma; \Sigma \vdash \tau . P}{ \Gamma; \Sigma \vdash P} \qquad
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape Guard}]{\Gamma \cup \Gamma_1 \cup \Gamma_2; \Sigma \vdash \ITE{e}{P_1}{P_2}}{\Gamma \vdash e : \mathbb{B} & \Gamma_1; \Sigma \vdash P_1 & \Gamma_2; \Sigma \vdash P_2} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QOp}]
{\Gamma; \Sigma \vdash \mathcal{E}(\widetilde{x}) . P}
{\mathcal{E}: Op(n) & |\widetilde{x}| = n & \forall i, j \ldotp x_i \neq x_j & \Sigma \vdash \widetilde{x} & \Gamma; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape QMeas}]{\Gamma; \Sigma \vdash M(\widetilde{x} \rhd y) . P}
{\forall i, j \ldotp x_i \neq x_j & \text{$y$ fresh} & \Sigma \vdash \widetilde{x} & \Gamma, y : \mathbb{N}; \Sigma \vdash P} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape CRecv}]
{\Gamma, c : \hat{T}; \Sigma \vdash c?x . P}
{\text{$x$ fresh} & T \neq \mathcal{Q} & \Gamma, x : T; \Sigma \vdash P} 
\qquad
\infer[\mbox{\footnotesize\scshape QRecv}]
{\Gamma, c : \hat{\mathcal{Q}}; \Sigma \vdash c?x . P}
{\text{$x$ fresh} & \Gamma, x : \mathcal{Q}; \Sigma, x \vdash P} 
\\[0.2cm]
\infer[\mbox{\footnotesize\scshape CSend}]{\Gamma, c : \hat{T}; \emptyset \vdash c!e}{T \neq \mathcal{Q} & \Gamma \vdash e : T} \qquad
\infer[\mbox{\footnotesize\scshape QSend}]{c : \hat{\mathcal{Q}}, e:\mathcal{Q} ; \set{e} \vdash c!e}{} \\[0.2cm]
%\infer[\mbox{\footnotesize\scshape QDiscard}]{e:\mathcal{Q} ; \set{e} \vdash discard(e)}{} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Sum}]{\bigcup_{i \in I}\Gamma_i; \Sigma \vdash \sum_{i \in I} P_i}{\forall i \ldotp \Gamma_i; \Sigma_i \vdash P_i} \qquad 
\infer[\mbox{\footnotesize\scshape Par}]{\bigcup_{i \in I}\Gamma_i; \bigcup_{i \in I}\Sigma_i \vdash \bigparallel_{i \in I} P_i}
{\forall i, j \ldotp \Sigma_i \cap \Sigma_j = \emptyset & \forall i \ldotp \Gamma_i; \Sigma_i \vdash P_i} \\[0.2cm]
\infer[\mbox{\footnotesize\scshape Rename}]{\Gamma; \Sigma \vdash P \{f\}}{f(\Gamma); \Sigma \vdash f(P)} \qquad
\infer[\mbox{\footnotesize\scshape Restrict}]{\Gamma - c; \Sigma \vdash P \setminus c}{\Gamma; \Sigma \vdash P} \\[0.3cm]
\end{gather*}

Where $$\Gamma - c = \begin{cases}
\Gamma \setminus \{c : \hat{T}\} \text{ if } c: \hat{T} \in \Gamma \text{ for some } \hat{T} \\
\Gamma \text{ otherwise}
\end{cases}$$

We say that the channel name $c$ is \textit{bound} in $P\setminus c$, and it is \textit{free} when it isn't bound by any restriction operator. We denote with $fc(P)$ the set of free channels of $P$.

\begin{definition}
  Assume a fixed set  $QVar = {q_1, q_2, \ldots q_n}$ of quantum variables, where each variable $q_i$ refers to a unique qubit with state space $\calH_i$. We denote as $\calH_{QVar}$ the $2^n$-dimensional Hilbert space $\bigoplus_{i=1}^n \calH_i$.

Let $P$ be a process and $\rho \in \mathcal{D}(\calH_{QVar})$ an arbitrary partial density operator. $\Gamma; \Sigma \vdash \langle \rho, P \rangle$ iff $\Gamma; \Sigma \vdash P$ and $\Sigma \subseteq QVar$.

  Let $I$ be an arbitrary index set. $\Gamma; \Sigma \vdash \boxplus_{i \in I} \langle \rho_i, P_i \rangle$ iff for each $i \in I$ such that $\rho_i \neq \mathbf{0}$,
  then $\Gamma; \Sigma \vdash \langle \rho_i, P_i \rangle$.
\end{definition}

%{\color{red} 
%Togliere Qvar da Gamma
%
%Rimuovere fresh da recv
%
%Aggiornare il proofs.
%}


\subsection*{Contexts}
A typed context $B$ is generated by the grammar
\[
B \Coloneqq \ [\_]_{\Gamma; \Sigma} \mid B \parallel P
\]
according to the typing rules:

\[
  \infer[\mbox{\footnotesize\scshape Hole}]{\Gamma; \Sigma \vdash [\blank]_{\Gamma; \Sigma}}{}
\qquad
\infer[\mbox{\footnotesize\scshape ParHole}]{\Gamma_1 \cup \Gamma_2; \Sigma_1 \cup \Sigma_2 \vdash B \parallel P}
{\Gamma_1; \Sigma_1 \vdash B & \Gamma_2; \Sigma_2 \vdash P & \Sigma_1 \cap \Sigma_2 = \emptyset}
\]


\begin{theorem}
	Given any context $B[\blank]$ of type $\Gamma; \Sigma$, with hole of type $\Gamma'; \Sigma'$, and any process $P$ s.t. $\Gamma'; \Sigma' \vdash P$, it holds that $\Gamma; \Sigma \vdash B[P]$ 
\end{theorem}
\begin{proof}
	Trivial.
\end{proof}